{
    "contents" : "MCSlabel<-function (x, y = NULL, labels = seq(along = x), cex = 1, method = c(\"CS\" \n), allowSmallOverlap = FALSE, trace = FALSE, doPlot = TRUE,Objective=c(\"dispersion\",\"mncp\",\"mncflp\"), \nNuClusters=nuclusters, Taumax=taumax, Bmax=bmax, T0=t0, TE=te, alpha=ALPHA,\nSAmax=samax, InitialSol=inisol,Inef=inef, ...) \n{\n  ####una etiqueta a modificar\n  #### se modifica el concepto de radio y se a?ade el concepto de lejan?a\n  #### se conserva la modificaci?n del centro y no s?lo del gen\n  if (!missing(y) && (is.character(y) || is.expression(y))) {\n    labels <- y\n    y <- NULL\n  }\n  labels <- as.graphicsAnnot(labels)\n  boundary <- par()$usr\n  xyAspect <- par()$pin[1]/par()$pin[2]\n  toUnityCoords <- function(xy) {\n    list(x = (xy$x - boundary[1])/(boundary[2] - boundary[1]) * \n           xyAspect, y = (xy$y - boundary[3])/(boundary[4] - \n                                                 boundary[3])/xyAspect)\n  }\n  toUserCoords <- function(xy) {\n    list(x = boundary[1] + xy$x/xyAspect * (boundary[2] - \n                                              boundary[1]), y = boundary[3] + xy$y * xyAspect * \n           (boundary[4] - boundary[3]))\n  }\n  z <- xy.coords(x, y, recycle = TRUE)\n  z <- toUnityCoords(z)\n  x <- z$x      \n  y <- z$y\n  if (length(labels) < length(x)) \n    labels <- rep(labels, length(x))\n  method <- match.arg(method)\n  if (allowSmallOverlap) \n    nudgeFactor <- 0.02\n  n_labels <- length(x)\n  width <- (strwidth(labels, units = \"figure\", cex = cex) + \n              0.015) * xyAspect\n  height <- (strheight(labels, units = \"figure\", cex = cex) + \n               0.015)/xyAspect\n  gen_offset <- function(code) c(-1, -1, -1, 0, 0, 1, 1, 1)[code] * \n    (width/2) + (0+1i) * c(-1, 0, 1, -1, 1, -1, 0, 1)[code] * \n    (height/2)\n  rect_intersect <- function(xy1, offset1, xy2, offset2) {\n    w <- pmin(Re(xy1 + offset1/2), Re(xy2 + offset2/2)) - \n      pmax(Re(xy1 - offset1/2), Re(xy2 - offset2/2))\n    h <- pmin(Im(xy1 + offset1/2), Im(xy2 + offset2/2)) - \n      pmax(Im(xy1 - offset1/2), Im(xy2 - offset2/2))\n    w[w <= 0] <- 0\n    h[h <= 0] <- 0\n    w * h\n  }\n  nudge <- function(offset) {\n    doesIntersect <- rect_intersect(xy[rectidx1] + offset[rectidx1], \n                                    rectv[rectidx1], xy[rectidx2] + offset[rectidx2], \n                                    rectv[rectidx2]) > 0\n    pyth <- abs(xy[rectidx1] + offset[rectidx1] - xy[rectidx2] - \n                  offset[rectidx2])/nudgeFactor\n    eps <- 1e-10\n    for (i in which(doesIntersect & pyth > eps)) {\n      idx1 <- rectidx1[i]\n      idx2 <- rectidx2[i]\n      vect <- (xy[idx1] + offset[idx1] - xy[idx2] - offset[idx2])/pyth[idx1]\n      offset[idx1] <- offset[idx1] + vect\n      offset[idx2] <- offset[idx2] - vect\n    }\n    offset\n  }\n  objective <- function(gene) {\n    offset <- gen_offset(gene)\n    if (allowSmallOverlap) \n      offset <- nudge(offset)\n    if (!is.null(rectidx1)){\n      if(Objective==\"dispersion\"){\n        area <- sum(rect_intersect(xy[rectidx1] + offset[rectidx1], \n                                   rectv[rectidx1], xy[rectidx2] + offset[rectidx2], \n                                   rectv[rectidx2]))\n      }else{if(Objective==\"mncp\"){area <- sum(rect_intersect(xy[rectidx1] + offset[rectidx1], \n                                                             \n                                                             rectv[rectidx1], xy[rectidx2] + offset[rectidx2], \n                                                             rectv[rectidx2])>0)\n                                  \n      }else{\n        intersect<-rect_intersect(xy[rectidx1] + offset[rectidx1], \n                                  rectv[rectidx1], xy[rectidx2] + offset[rectidx2], \n                                  rectv[rectidx2])\n        area<-0\n        for(i in 1:n_labels){\n          if(any(c(intersect[which(rectidx1==i)],intersect[which(rectidx2==i)])>0)){\n            area<- 1+area}\n        }\n      }\n      \n      }\n    }\n    else{area<-0} \n    n_outside <- sum(Re(xy + offset - rectv/2) < 0 | Re(xy + \n                                                          offset + rectv/2) > xyAspect | Im(xy + offset - rectv/2) < \n                       0 | Im(xy + offset + rectv/2) > 1/xyAspect)\n    if(Objective==\"dispersion\")\n      res <- 1000 * area + n_outside else res<- area + n_outside\n    \n    res\n  }\n  xy <- x + (0+1i) * y\n  rectv <- width + (0+1i) * height\n  rectidx1 <- rectidx2 <- array(0, (length(x)^2 - length(x))/2)\n  k <- 0\n  for (i in 1:length(x)) for (j in seq(len = (i - 1))) {\n    k <- k + 1\n    rectidx1[k] <- i\n    rectidx2[k] <- j\n  }\n  canIntersect <- rect_intersect(xy[rectidx1], 2 * rectv[rectidx1], \n                                 xy[rectidx2], 2 * rectv[rectidx2]) > 0\n  rectidx1 <- rectidx1[canIntersect]\n  rectidx2 <- rectidx2[canIntersect]\n  if (trace) \n    cat(\"possible intersects =\", length(rectidx1), \"\\n\")\n  if (trace) \n    cat(\"portion covered =\", sum(rect_intersect(xy, rectv, \n                                                xy, rectv)), \"\\n\")\n  #M?todo CS \n  #######################################################################\n  cs <- function() {\n    # Se inicializan par?metros.\n    LocalSearch<-function(geneCe){\n      repeat{\n        antscoreCe<-objective(geneCe)\n        scoreCe<-antscoreCe\n        newgeneCe<-geneCe\n        for(i in 1:n_labels){\n          for(j in 1:8){\n            if(as.double(geneCe[i])!=j){\n              newgeneCe[i] <- j\n              newscoreCe<-objective(newgeneCe)\n              if (newscoreCe < scoreCe) {\n                geneCe <- newgeneCe\n                scoreCe <- newscoreCe\n                \n              }else{newgeneCe[i]<-geneCe[i]}\n            }\n          }\n          \n          \n        }\n        if(antscoreCe<=scoreCe){\n          break\n        }\n      }\n      return(geneCe)\n    }\n    \n    C<-list()\n    scoreC<-rep(0,NuClusters)\n    Tau<-rep(0,NuClusters)\n    B<-rep(0,NuClusters)\n    gene<-InitialSol\n    score <- objective(gene)\n    bestgene <- gene\n    bestscore <- score\n    per<-floor(n_labels*Inef)\n    \n    ###########################\n    \n    #se crean soluciones representantes del grupo\n    for(i in 1:NuClusters){\n      \n      C[[i]] <- sample(1:8,n_labels,replace=T)\n      scoreC[i]<-objective(as.double(C[[i]]))\n    }\n    ############################################\n    \n    \n    while (T0 > TE) {\n      bestscoreant<-bestscore #condici?n de no cambio \n      #Simulated Annealing\n      for (j in 1:SAmax) {\n        newgene <- gene\n        newgene[sample(1:n_labels, 1)] <- sample(1:8, \n                                                 1)\n        newscore <- objective(newgene)\n        if (newscore <= score || runif(1) < exp((score - \n                                                   newscore)/T)) {\n          \n          score <- newscore\n          gene <- newgene\n        }\n        #Nota: se le a?ade esto al c?digo del Paper (2014)\n        if (score <= bestscore) {\n          bestscore <- score\n          bestgene <- gene\n        }\n        if (bestscore == 0) \n          break\n        ###################################################\n      }\n      ####################\n      \n      T0 <- alpha * T0\n      #distancia de Hamming respecto a S\n      dist<-rep(0,NuClusters)\n      for(i in 1:NuClusters){\n        dist[i]<-sum(mapply(identical,as.integer(gene),C[[i]])) #typeof(gene)=double, typeof(c[[i]])=intenger\n      }\n      \n      \n        Pmax<-which(dist== max(dist)) #posici?n de el/los Centro(s) m?s cercano(s) a S\n        Tau[Pmax[1]]<-Tau[Pmax[1]]+1\n        \n      if(score<=scoreC[Pmax[1]]) {#best center\n          C[[Pmax[1]]]<-as.integer(gene)\n          scoreC[Pmax[1]]<-score\n        }\n    \n      if(Tau[Pmax[1]]==Taumax){\n        Tau[Pmax[1]]<-0\n        gene<-LocalSearch(as.double(C[[Pmax[1]]]))\n        score<-objective(gene)\n        \n        #Nota: se le a?ade esto al c?digo del Paper (2014)\n        if (score <= bestscore) {\n          bestscore <- score\n          bestgene <- gene\n        }\n        #################################################\n        if(score==scoreC[Pmax[1]]){\n          B[Pmax[1]]<-B[Pmax[1]]+1\n          if(B[Pmax[1]]==Bmax){\n            pos_change<-sample(1:n_labels,per)\n            C[[Pmax[1]]][pos_change]<-sample(1:8,length(pos_change),replace=T)\n            scoreC[Pmax[1]]<-objective(as.double(C[[Pmax[1]]]))\n            C[[Pmax[1]]]<-as.integer(C[[Pmax[1]]])\n            B[Pmax[1]]<-0\n          }\n          \n        }else{\n          B[Pmax[1]]<-0\n          ##########################esto lo agrego yo#########################\n          C[[Pmax[1]]]<-as.integer(gene)\n          scoreC[Pmax[1]]<-score\n          ####################################################################\n        }\n        \n      }\n      if (scoreC[Pmax[1]] <= bestscore) {\n        bestscore <- scoreC[Pmax[1]]\n        bestgene <- as.double(C[[Pmax[1]]])\n      }  \n      \n      if (bestscore == 0) \n        break\n      if (trace) \n        cat(\"overlap area =\", bestscore, \"\\n\")\n    }\n    \n    \n    if (trace) \n      cat(\"overlap area =\", bestscore, \"\\n\")\n    nx <- Re(xy + gen_offset(bestgene))\n    ny <- Im(xy + gen_offset(bestgene))\n    list(x = nx, y = ny)\n    \n  }\n\n  xy <- cs()\n  xy <- toUserCoords(xy)\n  if (doPlot) \n    text(xy, labels, cex = cex)\n  invisible(xy)\n\n}",
    "created" : 1447456277891.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3483306913",
    "id" : "C3EDA2F0",
    "lastKnownWriteTime" : 1441253964,
    "path" : "~/Repositorios/2015/graficas/lib/MCSlabel.R",
    "project_path" : "lib/MCSlabel.R",
    "properties" : {
    },
    "relative_order" : 0,
    "source_on_save" : false,
    "type" : "r_source"
}